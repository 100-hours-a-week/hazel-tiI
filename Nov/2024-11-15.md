## 날짜: 2024-11-15

### [데이터베이스] 



### InnodDB, MYISAM 특성 비교 
- InnodDB : 트랜잭션 처리와 대용량 데이터 처리에 효율적인 엔진
    - 트랜잭션 지원 
    - row-level locking 지원
    - 외래 키 제약 조건 지원
    - 자동 복구 기능
- MYISAM : 읽기 위주의 작업에 효율적인 엔진  
    - 비트랜잭션 테이블 관리
    - table-level locking
    - 전체 텍스트 검색 지원 
    - 간단한 데이터 모델 디자인 


### mariadb Daemon 
- Daemon : 운영체제에서 사용자가 직접 제어하지 않고 백그라운드에서 작업을 처리하는 프로그램 통칭 
- 데몬 프로그램은 이름 마지막에 보통 d를 붙임 
- 시스템 로그를 남기는 : syslogd
- 일반적으로 프로세스로 실행됨 


### 백그라운드
- 사용자 간섭 없이 보이지 않는 뒷편에서 실행되는 컴퓨터 프로세스 




---



### 스키마 
- 데이터베이스 구조를 정의하는 개념 
- 테이블, 인덱스 (뷰, 저장 프로시저, 트리거)등을 포함할 수 있음 괄호 안은 잘 안쓰임  
- MySQL에서는 스키마가 데이터베이스와 동일한 의미로 사용됨 

### 스키마 종류 
개념적 스키마, 논리적 스키마, 물리적 스키마 

### 개념적 스키마
- 개념적 스키마 : 데이터베이스에 저장되는 주요 개념과 이들 간의 관계를 정의함 
- 도메인 파익. 커뮤니케이션, 문서화를 위해 필요 

### 논리적 스키마 
- 개념적 스키마를 기반으로 구체적인 데이터베이스 설계
- 컬럼끼리 관계 설정해주는 것 
- 테이블의 컬럼과 타입 등을 자세히 적어 실제 테이블의 구조를 나타낼 수 있는 ER다이어그램 
- 데이터 무결성 및 독립성을 위해 필요 
- pk(primary key) : 식별을 위해 사용하는 키로 유일성과 최소성을 만족함 
- fk(foreign key) : 외부 테이블의 기본 키를 참조하는 열로 테이블의 관계를 설정하는 데 사용 

### 물리적 스키마 
- 논리적 스키마를 실제 데이터베이스 관리 시스템(DBMS)에서 구현한 것 
- 데이터가 실제로 저장되는 방법, 인덱스, 파티셔닝 등을 포함 
- 성능 최적화, 구현 세부사항, 자원관리에 필요 




---




### 테이블 
- 데이터베이스에서 데이터를 구조적(컬럼)으로 저장하는 기본 단위 

### 테이블 구성요소
- 열(column) 또는 속성 : 테이블의 세로단위, 각 열은 특정 데이터 유형을 가진 필드를 나타냄 
- 행(row) 또는 레코드 : 테이블의 가로단위, 각 행은 하나의 데이터 항목 또는 레코드를 나타냄 




---



### 인덱스 (=범위)
- 데이터베이스 검색 속도를 향상 시키기 위해 사용되는 데이터 구조 
- 특정 컬럼에 대해 인덱스를 생성하면 해당 컬럼을 기준으로 레코드를 빠르게 찾을 수 있음 
- 인덱스 이름이 짧을 수록 좋음 
- 인덱싱을 할 수 있는 값을 인덱스로 설정해야 함 (인덱스를 키처럼 쓰면 안됨)
- `CREATE INDEX` 명령을 사용해 생성할 수 있음 
- 쿼리 중 `SELECT`가 대부분이기 때문에 인덱스를 많이 사용함 

### 쿼리 
1. 생성 : `INSERT` 새로운 행에 데이터 추가
2. 조회 : `SELECT` 하나 이상의 행을 검색하여 정보 조회
3. 업데이트 : `UPDATE` 기존 행의 데이터 수정 
4. 삭제 : `DELETE` 하나 이상의 행 데이터 삭제 


### `INSERT` 기본 형식
`INSERT INTO 테이블명 (열1, 열2, ...) VALUES (값1, 값2, ...);`


 ### `SELECT` 사용법
 - 특정 열 선택 : `SELECT 열1, 열2 FROM 테이블명`;
 - 조건부 선택 : `SELECT * FROM 테이블명 WHERE 조건`;
 - 정렬 : `SELECT * FROM 테이블명 ORDER BY 열 [ASC|DESC];`
 - 그룹화 : `SELECT 열, COUNT(*) FROM 테이블명 GROUP BY 열;`
 - 중복 제거 : `SELECT DISTINCT 열 FROM 테이블명;`



### 업데이트 사용법
- `WHERE`절 신중하게 사용하기 
- 여러 열 동시 업데이트 : `UPDATE 테이블명 SET 열1 = 값1, 열2 = 값2 WHERE 조건;`
- 서브쿼리를 이용한 업데이트 : `UPDATE 테이블명 SET 열 = (SELECT ...) WHERE 조건;`



### 삭제 사용법 
- 조건부 삭제 : `DELETE FROM 테이블명 WHERE 조건;`
- 서브쿼리를 이용한 삭제 : `DELETE FROM 테이블명 WHERE 열 IN (SELECT ...);`
- 조인을 사용한 삭제 : `DELETE t1 FROM 테이블1 t1 JOIN 테이블2 t2 ON t1.id = t2.id WHERE 조건; `


### SELECT 쿼리의 논리적 실행 순서
1. FROM : 테이블/뷰 같은 데이터 소스 지정 
2. JOIN : 다른 테이블과 결합 
3. WHERE : 결합된 테이블에서 조건에 맞는 레코드만 필터링
4. GROUP BY : 특정 컬럼을 기준으로 레코드 그룹화
5. HAVING : 절에 의해 그룹화된 결과에 대한 조건 지정
6. SELECT : 출력할 컬럼 선택 
7. DISTINCT : 중복된 레코드 제거 
8. ORDER BY : 결과를 특정 컬럼을 기준으로 정렬 
9. LIMIT : 결과에서 반환할 레코드 수 제한 



### 쿼리가 실행시간 목표 
- 쿼리 실행 시간은 100ms 이내로 유지하는 것이 이상적 



---


### JOIN
두 개 이상의 테이블을 결합해서 데이터를 조회하는 방법 


### JOIN 사용이유
- 데이터 결합 : 여러 테이블의 데이터를 결합해 유의미한 정보 생성 
- 관계 표현 : 관계형 데이터베이스에서 테이블 간의 관계 표현
- 효율성 : 한 쿼리로 한 번에 여러 테이블의 데이터 조회
- 유지보수 : 테이블을 개별적으로 관리 및 유지보수 할 수 있음 -> 조인을 통해 통합 조회가 가능하니까 


### LEFT JOIN
- 왼쪽 테이블의 모든 레코드와 오른쪽 테이블의 일치하는 레코드 반환 -> 이 과정에 NULL 값이 생길 있음 

### RIGHT JOIN
- 오른쪽 테이블의 모든 레코드와 왼쪽 테이블의 일치하는 레코드 반환 -> 이 과정에 NULL 값이 생길 있음 

### CROSS JOIN
- 조회 결과 값이 모든 경우의 수를 포함 
- Slow query : 요청받은 쿼리를 수행할 때 일정 시간 이상 수행 되지 못한 쿼리 



---





### 오늘의 도전 과제와 해결 방법
- **도전 과제**: 데이터베이스 쿼리 조작 해보기
- **어려웠던 점**: dbever를 처음 사용해 봐서 세팅하는 시간이 오래 소모되었다. RDS 설정할 때 포트를 제한했더니 계속해서 타임아웃이 발생하였다. 그리고 쿼리문을 보내면 Incorrect string value라는 문자 인코딩 오류 문제가 있었다.
- **해결 방법**: 쉬는 시간을 활용해 같은 문제를 가진 블로그 글을 참고하여 해결하였다. 포트 설정을 재검토하여 수정하였고 문자 인코딩 문제는 데이터베이스와 클라이언트의 인코딩 설정을 일치시켜 해결하였다. 

### 오늘의 회고
- [강의]: 그동안 알고는 있었지만 정확히 설명할 순 없었던 데이터베이스 개념들을 다시 한 번 정립할 수 있는 시간이라 좋았다. 팀원들과 함께 배운 내용을 정리하며 리마인드 할 수 있는 시간도 의미 있었다. 

