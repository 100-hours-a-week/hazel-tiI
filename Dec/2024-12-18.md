## 날짜: 2024-12-18

## 오늘의 회고 

### 트랜잭션 
저번에 트랜잭션에 대해 간단히 정리를 해봤는데 이번에 직접 적용하며 헷갈렸던 부분을 중심으로 다시 정리해보고자 한다.   
- 트랜잭션은 한 번에 수행 되어야 할 연산들의 모음을 의미한다. 
- 원자성을 보장하기 위해 다음과 같은 방법을 사용한다. 
  - 데이터베이스에서 테이블의 데이터를 읽어 온 뒤 다른 테이블에서의 데이터 처리 도중 문제가 발생한다면 이전 작업들을 원래의 상태로 롤백한다.
  - 모든 처리 과정이 성공 했을 경우에만 결과를 커밋한다.  

### 예시를 통한 이해 : 입금과 송금 예시
1. A가 B의 계좌에 100만원을 송금하였다. 
2. 하지만 B의 계좌에는 100만원이 입금되지 않았다. <br>
위의 예시가 원자성이 지켜지지 않은 대표적인 예시이다. 작업의 성공 여부와 관계 없이 데이터가 변경될 경우 위 처럼 안전성에 문제가 생긴다.  
그렇기 때문에 모든 작업이 성공 했을 경우에만 결과를 실패 시 이전 상태로 복원을 진행한다.  

<br>

### 트랜잭션 작업 단위 
#### 여러 여러 SQL문을 하나의 트랜잭션을 묶은 것을 작업 단위라고 한다. 
1. 게시글을 작성하는 것은 `INSERT`문을 사용한다. 
2. 게시글 목록을 불러오는 것은 `SELECT`문을 사용한다. <br>
위 두 작업을 하나의 트랜잭션으로 처리가 가능하다. 



<br>


### 트랜잭션의 특징 
1. 원자성 : 트랜잭션 단위로 데이터가 처리 된다는 것은 작업이 모두 반영 되거나 모두 반영되지 않는 것을 의미한다. 일부만 반영될 순 없다. 
2. 일관성 : 트랜잭션의 작업 결과는 항상 일관되어야 한다. 트랜잭션 진행 중 데이터베이스가 변경 되더라도 변경 사항을 작업에 바로 반영하지 않는다. 
3. 독립성 : 각 트랜잭션은 독립성을 가지기 때문에 다른 트랜잭션의 연산에 끼어들 수 없다. 이 때문에 다른 트랜잭션이 중간 결과를 참조할 수 없다. 
4. 영구성 : 성공한 트랜잭션의 결과는 데이터베이스에 영구적으로 반영된다.  
 

<br>


### 작업 흐름 
#### 1. 작업 중
[활성 상태] 트랜잭션이 정상적으로 실행 중인 상태를 의미한다.  
#### 2. 작업 완료 
[부분 완료] 트랜잭션의 작업이 마무리 되었지만 커밋이 되지 않아 데이터베이스에 반영이 되지 않은 상태이다.  
[완료] 성공한 트랜잭션 커밋이 반영 된 상태이다.
#### 3. 작업 실패
[실패] 트랜잭션 실행 중 오류가 발생해서 작업이 중단된 상태를 의미한다. 
[철회] 트랜잭션 작업이 비정상적으로 종료되어 롤백 연산을 통해 변경 사항을 취소한 상태를 의미한다. 


<br>


### 트랜잭션 사용 시 주의할 점
1. DDL 명령어와 트랜잭션
    - DDL 명령어는 트랜잭션의 롤백 명령이 적용되지 않는다. 
    - 대표적인 DDL 명령어 : `CREATE`, `DROP`, `ALTER`, `RENAME`, `TRUNCATE`
2. 트랜잭션 사용 시 작업 단위를 명확히 정의하고 적절히 커밋/롤백을 수행해야 한다. 


<br>


### 프로젝트에 적용하기 : 좋아요 버튼 구현 
#### 게시글의 좋아요 버튼을 구현하기 위한 트랜잭션 적용 및 테이블 구조 정리 

### 좋아요 버튼 로직
#### 좋아요 상태 확인 : 사용자가 이미 좋아요를 눌렀는지 확인한다.
- 좋아요를 눌렀을 경우 
  - `LIKES`의 좋아요를 삭제한다.
  - `POST`의 좋아요 수를 감소시킨다. 
- 좋아요를 누르지 않았을 경우 
  - `LIKES`의 좋아요를 추가한다. 
  - `POST`의 좋아요 수를 증가시킨다. 

### 트랜잭션 처리 
- 모든 작업은 트랜잭션 내에서 처리한다. 
- 만약 중간에 문제가 발생하더라도 데이터가 일관된 상태를 유지하도록 설계한다. 
- 작업 순서 
1. `SELECT` : 좋아요 상태 확인
2. 상태에 따른 `INSERT`/`DELETE` 및 게시글 좋아요 수의 `UPDATE` 실행
3. 성공 시 `COMMIT`, 실패 시 `ROLLBACK`

### 테이블 구조
#### POST
 Field   | Type          | Description                             
:-------:|:-------------:|:---------------------------------------:
 post_id | INT(11)       | 게시글 고유 ID (Primary Key, Auto Increment) 
 user_id | INT(11)       | 게시글 작성자 ID (Foreign Key)                
 Field   | Type          | Description                             
 post_id | INT(11)       | 게시글 고유 ID (Primary Key, Auto Increment) 
 user_id | INT(11)       | 게시글 작성자 ID (Foreign Key)                
 title   | VARCHAR(255)  | 게시글 제목                                  
 content | TEXT          | 게시글 내용                                  
 image   | VARCHAR(2083) | 게시글 이미지 경로                              
 view    | INT(11)       | 게시글 조회 수 (기본값: 0)       
#### LIKES 
 Field   | Type    | Description                             
:-------:|:-------:|:---------------------------------------:
 like_id | INT(11) | 좋아요 고유 ID (Primary Key, Auto Increment) 
 post_id | INT(11) | 좋아요를 받은 게시글 ID (Foreign Key)            
 user_id | INT(11) | 좋아요를 누른 사용자 ID (Foreign Key)  



<br>


### 오늘의 회고
- 프로젝트를 진행하며 중간중간 모르는 내용이 있을 때 이를 정리해두는 습관이 큰 도움이 된다. 어떤 부분을 고려해야 하고, 어떤 점을 주의해야 하는지 명확히 
이해한 상태에서 구현해야 효율적으로 작업할 수 있기 때문이다.
- 특히 `LIKES` 테이블을 분리하지 않았을 경우에는 좋아요를 효율적으로 관리하기 어렵고 데이터 중복 및 무결성 문제가 발생할 가능성이 높다. 
그렇기 떄문에 `LIKES`테이블을 분리했지만 이로 인해 복잡하고 트랜잭션 로직을 작성해야 했다. 
- 구현하는 과정에서 헷갈리는 부분이 많았지만 개념을 다시 정리하면서 작업이 훨씬 수월해져 좋았다. 

<br>

- [참고] : https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC 
